---
title: "Título"
author: "Theil, Gustavo"
date: "2024-05-23"
output:
  html_document: default
  pdf_document: default
---


```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(sf)
library(kableExtra)
library(knitr)
library(units)
library(gt)
library(patchwork)
library(purrr)
library(ggtext)

set.seed(123)
```


```{r setup, include=FALSE}
opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache.lazy = FALSE)
setwd("C:/git/densidade")
```

# Geosampa

GeoSampa é o portal de mapas e dados geoespaciais da cidade de São Paulo, mantido pela prefeitura. Ele fornece uma vasta gama de informações geográficas, incluindo mapas, dados demográficos, infraestruturas e muito mais. Este portal é uma ferramenta valiosa para pesquisadores, urbanistas e qualquer pessoa interessada em informações espaciais detalhadas sobre a cidade.

https://geosampa.prefeitura.sp.gov.br/

# Lotes
Base de Lotes: No GeoSampa, a base de lotes representa a divisão da cidade em pequenos segmentos, geralmente correspondentes a terrenos individuais ou condomínios. Esta base está organizada de forma que cada bairro tem seu próprio conjunto de dados e os dados de lotes para cada bairro podem ser baixados diretamente do site do GeoSampa em formato zip, contendo arquivos como .shp (shapefile), .dbf (database file), e .shx (index file).


```{r}
# Extração do zip file com lotes de cada bairro
if (!"zip" %in% list.files(path = "dados/lotes")){
  for (file in list.files(path="dados/lotes/zip", full.names = FALSE) %>% 
       str_remove("\\.zip")){
    unzip(paste("dados/lotes/zip/", file, ".zip", sep = ""), 
          paste(file, "/", file, ".shp", sep = ""), 
          exdir = "dados/lotes/unzip")
    unzip(paste("dados/lotes/zip/", file, ".zip", sep = ""), 
          paste(file, "/", file, ".dbf", sep = ""), 
          exdir = "dados/lotes/unzip")
    unzip(paste("dados/lotes/zip/", file, ".zip", sep = ""), 
          paste(file, "/", file, ".shx", sep = ""), 
          exdir = "dados/lotes/unzip")
  }
}
```

```{r lotes_bruto, cache = TRUE}
# Junção dos shapes dos lotes de cada bairro em uma tabela
lotes <- list.files(path="dados/lotes/unzip", full.names = FALSE) %>% 
    paste("dados/lotes/unzip/", ., "/", ., ".shp", sep = "") %>% 
    lapply(read_sf) %>% 
    bind_rows %>% 
    st_set_crs("epsg:31983") 

```

```{r, echo = FALSE}
lotes %>% 
  ungroup() %>% sample_n(8) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

## Tipos de lotes

Os lotes podem ser classificados de três formas

- Lotes fiscais: apresentam contribuintes do IPTU
- Espaço livre: espaços públicos
- Via de acesso: Ruas fechadas para acesso dentro de uma quadra

Os lotes fiscais podem ser unidades ou condomínios. Um prédio, por exemplo, fica em um único lote, mas dentro pode haver diversas unidades, então se configura como um condomínio. Não é possível saber através dos dados de lotes quantas unidades estão no condomínio, nem alguma forma de discriminá-los.


```{r plot_lotsizes, cache = TRUE}
lotes %>% 
  mutate(condominio = case_when(lo_condomi == "00" ~ "Unidade",
                                lo_condomi != "00" ~ "Condomínio"),
         tipo = case_when(lo_tp_lote == "F" ~ "Fiscal",
                          lo_tp_lote == "M" ~ "Espaço livre",
                          lo_tp_lote == "V" ~ "Via de acesso",
                          .default = NA),
         area = st_area(geometry) %>% as.numeric()) %>% 
  st_drop_geometry() %>% 
  ggplot() +
  geom_violin(aes(x = factor(condominio), y = area, fill = tipo)) +
  scale_y_log10(labels = scales::comma_format(big.mark = ".")) +
  labs(title = "Área dos lotes em SP" , x = "", y = "Área em metros quadrados", fill = "Tipo de lote") +
  theme_classic()
```



## SQL dos Lotes (Setor, Quadra e Lote)
Na base de dados de lotes, cada lote é identificado por três componentes principais:

1. Setor (lo_setor): Uma divisão maior dentro do município que agrupa várias quadras.
2. Quadra (lo_quadra): Uma subdivisão dentro de um setor que agrupa vários lotes.
3. Lote (lo_lote): A menor unidade de divisão, que representa um terreno ou uma parcela específica dentro de uma quadra.
Essa estrutura de Setor-Quadra-Lote é crucial para identificar de forma única cada lote dentro do município. No código, esses identificadores são utilizados para manipular e cruzar os dados de lotes com outras bases de dados, como a base de IPTU.

```{r lotes_tratado, cache = TRUE}
lotes <- lotes %>% 
 filter(lo_tp_lote == "F") %>% # Seleção apenas de lotes fiscais
  mutate(lo_lote = ifelse(lo_lote == "0000", paste("CD", lo_condomi, sep = ""), lo_lote)) %>% 
  select(setor = lo_setor, quadra = lo_quadra, lote = lo_lote)
```

```{r, echo = FALSE}
lotes %>% 
  ungroup() %>% sample_n(8) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```


# Base de Dados do IPTU

A base de dados do IPTU (Imposto Predial e Territorial Urbano) é uma fonte abrangente de informações sobre imóveis urbanos dentro do município. Essa base é considerada completa, pois abrange todos os imóveis sujeitos à tributação do IPTU, representando uma fonte confiável e abrangente de informações sobre a propriedade urbana. Propriedades que não foram construídas dentro da legalidade não constam nessa base.

O número do contribuinte, utilizado para identificar exclusivamente cada imóvel na base de dados do IPTU, é representado diretamente pelo SQL, sendo essencial para consultas e manipulação dos dados relacionados ao imposto predial e territorial urbano. Esse formato permite a integração e cruzamento com outras bases de dados, como a base de lotes, que está georreferenciada, fornecendo informações espaciais adicionais que não estão disponíveis na base do IPTU.

## Procedimento para Lotes de Condomínios

Quando um lote é um condomínio, ou seja, quando não se classifica de acordo com `condominio == "00-0"`, é necessário substituir os múltiplos números de SQL pelo número do condomínio. Isso ocorre porque cada unidade dentro do condomínio pode ser tratada como uma entidade separada para fins tributários, mas para a base de lotes, estão todos juntos.


```{r IPTU_bruto, cache = TRUE}
IPTU <- read.csv("dados/IPTU/IPTU_2024.csv", sep=";", encoding = "latin1") %>% 
    as_tibble() %>% 
    select(sql = "NUMERO.DO.CONTRIBUINTE", 
           condominio = "NUMERO.DO.CONDOMINIO",
           area_terreno = "AREA.DO.TERRENO",
           area_construida = "AREA.CONSTRUIDA",
           area_ocupada = "AREA.OCUPADA",
           pavimentos = "QUANTIDADE.DE.PAVIMENTOS",
           ano_construcao = "ANO.DA.CONSTRUCAO.CORRIGIDO",
           tipo = "TIPO.DE.PADRAO.DA.CONSTRUCAO") %>% 
    
    # Separação do número de contribuinte (SQL) em setor quadra e lote
    mutate(setor =  str_sub(sql, 1, 3),
           quadra = str_sub(sql, 4, 6),
           
           # Quando o lote é um condomínio, haverá vários SQLs no mesmo lote. CD = Condomínio
           lote = str_sub(sql, 7, 10) %>% 
             ifelse(condominio == "00-0", ., paste("CD", str_sub(condominio, 1, 2), sep = "")),
           
           # Tipo de uso
           residencial = str_detect(tipo, "Residencial"))
```

```{r, echo = FALSE}
IPTU %>% 
  ungroup() %>% sample_n(8) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

## Tipos de uso para IPTU

Todos os empreendimentos não públicos regulares (de acordo com a lei) constam nesta base de dados. A seguir está uma análise de quais são estes tipos. O tipo de interesse para esta análise é apenas os residenciais.


```{r}
IPTU.tipos <- IPTU %>% 
  group_by(tipo) %>% 
  summarize(n = n()) %>% 
  mutate(percentual = n/sum(n)) %>% 
  rename("Tipo de contribuinte" = tipo) 
```

```{r, echo = FALSE}
IPTU.tipos %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
remove(IPTU.tipos)
```

```{r grafico_area_construida, cache = TRUE}
gg.right <- IPTU %>% 
  mutate(uso = case_when(str_detect(tipo, "Residencial") ~ "Residencial",
                         str_detect(tipo, "Comercial") ~ "Comercial",
                         str_detect(tipo, "Oficina") ~ "Industria",
                         str_detect(tipo, "TERRENO") ~ "Terreno",
                         str_detect(tipo, "Clube") ~ "Entretenimento",
                         .default = "Outros") %>% as.factor(),
         padrao = case_when(str_detect(tipo, "A$") ~ "A",
                            str_detect(tipo, "B$") ~ "B",
                            str_detect(tipo, "C$") ~ "C",
                            str_detect(tipo, "D$") ~ "D",
                            str_detect(tipo, "E$") ~ "E",
                            .default = "NA"),
         nome = paste("(", padrao, ") ", uso, sep = "")) %>% 
  group_by(uso, padrao, nome) %>% 
  summarize(area = sum(area_construida)) %>% 
  ungroup() %>% 
  mutate(percentual = area * 100/ sum(area, na.rm = TRUE),
         texto = case_when(percentual < 1 ~ "<1%",
                           percentual < 5 ~ paste(round(percentual,1), "%", sep = ""),
                           .default = paste(round(percentual, 2), "%", sep = "")),
         color = ifelse(uso == "Outros", "white", "black")) %>% 
  ggplot() +
  treemapify::geom_treemap(aes(fill = uso, area = area), size = 2, color = NA) +
  treemapify::geom_treemap(aes(alpha = padrao, area = area), fill = "black", color = NA) +
  treemapify::geom_treemap_text(aes(area = area, label = nome, color = color), alpha = .4, grow = FALSE, size = 8) +
  treemapify::geom_treemap_text(aes(area = area, label = texto, color = color), 
                                alpha = .4, place = "middle", size = 10) +
  scale_fill_manual(values = c("Residencial" = "#FAE48B", 
                               "Comercial" = "#A6EEE6",
                               "Industria" = "#84BD00",
                               "Entretenimento" = "#FB6467",
                               "Outros" = "#1A5354")) +
  scale_alpha_manual(values = c("A" = 0, "B" = .05, "C" = .1, "D" = .15, "E" = .2, "NA" = 0)) +
  scale_color_manual(values = c("black" = "black", "white" = "white")) +
  labs(fill = "Tipo de uso", alpha = "Parão de uso") +
  theme(aspect.ratio=1)

gg.left <- IPTU %>% 
  mutate(uso = case_when(str_detect(tipo, "Residencial") ~ "Residencial",
                         str_detect(tipo, "Comercial") ~ "Comercial",
                         str_detect(tipo, "Oficina") ~ "Industria",
                         str_detect(tipo, "TERRENO") ~ "Terreno",
                         str_detect(tipo, "Clube") ~ "Entretenimento",
                         .default = "Outros") %>% as.factor()) %>% 
  group_by(uso) %>% 
  summarize(area = sum(area_construida, na.rm = TRUE)) %>% 
  ungroup() %>% 
  arrange(desc(uso)) %>% 
  mutate(percentual = area * 100 / sum(area, na.rm = TRUE),
         texto = ifelse(percentual > 5, paste(round(percentual, 1), "%", sep = ""), ""),
         ytext = (cumsum(area) + lag(cumsum(area)))/ 2) %>% 
  ggplot() +
  geom_col(aes(y = area, fill = uso, x = "")) +
  geom_text(aes(y = ytext, fill = uso, x = "", label = texto), alpha = .5) +
  scale_fill_manual(values = c("Residencial" = "#FAE48B", 
                               "Comercial" = "#A6EEE6",
                               "Industria" = "#84BD00",
                               "Entretenimento" = "#FB6467",
                               "Outros" = "#1A5354")) +
  theme_void() +
  theme(legend.position = "none")

ggsave("tex/imagens/tree_area_construida.png", 
       (gg.left | gg.right) + 
         plot_layout(widths = c(1,6)), 
       width = 10, height = 8, dpi = 250)

```

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/tree_area_construida.png")
remove(gg.left, gg.right)
```

## Agrupamento dos condomínios

Quando há um condomínio com múltiplos contribuintes de IPTU, ele deve ser agregado a nível lote, para que possa ser cruzado com a base de lotes, possibilitando que seja georreferenciada. Todos os contribuintes dentro de um condomínio compartilham das mesmas características de área de terreno, área ocupada, ano de construção e pavimentos, então a mediana funciona para agregar estes dados, mas o máximo, mínimo, média ou pegar o primeiro valor também funcionaria.



```{r IPTU_tratado, cache = TRUE}
IPTU <- IPTU %>% 
  group_by(setor, quadra, lote) %>% 
  
  # Agregar por SQL
  group_by(setor, quadra, lote) %>% 
  summarize(unidades = n(),
            area_terreno = median(area_terreno), 
            area_construida = sum(area_construida), 
            area_ocupada = median(area_ocupada),
            pavimentos = median(pavimentos),
            ano_construcao = median(ano_construcao),
            residencial = median(residencial))
```

```{r, echo = FALSE}
IPTU %>% 
  ungroup() %>% sample_n(8) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

# Join entre a Base de Lotes e a Base do IPTU

```{r join_IPTU-lotes, cache = TRUE}
# Join dos lotes com IPTU com base no SQL
IPTU.lotes <- IPTU %>% 
  left_join(lotes, by = join_by(setor, quadra, lote)) %>% 
  ungroup()
```

```{r, echo = FALSE}
remove(IPTU)

IPTU.lotes %>% 
  ungroup() %>% sample_n(8) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

## Algumas estatísticas descritivas

```{r plot_distancia_pavimentos, cache = TRUE}
gg <- IPTU.lotes %>% 
  filter(residencial == 1) %>% 
  mutate(distancia_centro = st_distance(geometry, 
                                        read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") %>% 
                                          st_set_crs("epsg:31983") %>% 
                                          filter(ds_nome == "SE")) %>% 
           as.numeric() %>% 
           cut(breaks = 10^3*(0:40), labels = FALSE)) %>% 
  st_drop_geometry() %>% 
  group_by(distancia_centro) %>% 
  summarize(pavimentos = weighted.mean(pavimentos, area_ocupada)) %>% 
  ggplot(aes(x = distancia_centro, y = pavimentos)) +
  geom_col() +
  geom_hline(yintercept = 2, linetype = "dotted") +
  labs(x = "Distância ao centro em quilômetros", 
       y = "Pavimentos") + 
  scale_y_continuous(breaks = (1:5)*2) +
  theme_classic()

ggsave("tex/imagens/pavimentos.png", gg, width = 6, height = 4, dpi = 250)

```

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/pavimentos.png")
remove(gg)
```

```{r plot_indicadores, cache = TRUE}
gg <- IPTU.lotes %>% 
  filter(residencial == TRUE) %>% 
  st_drop_geometry() %>% 
  mutate(CA = area_construida / area_terreno,
         cota_parte = area_terreno / unidades) %>% 
  filter(cota_parte < 500, CA < 5, pavimentos < 30) %>% 
  pivot_longer(c(CA:cota_parte, pavimentos)) %>% 
  ggplot() +
  geom_histogram(aes(x = value)) +
  facet_wrap(~ name, scales = "free") +
  labs(title = "Distribuição dos indicadores em SP", x = "", y = "Frequência") + 
  theme_classic()

ggsave("tex/imagens/indicadores.png", gg, width = 9, height = 5, dpi = 250)

```

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/indicadores.png")
remove(gg)
```

## Outliers

Alguns IPTUs apresentam inconsistências, como um terreno de 400.000 metros quadrados com apenas uma unidade residencial.

```{r outliers, cache = TRUE}
outliers <- IPTU.lotes %>% 
  filter(residencial == TRUE) %>% 
  st_drop_geometry() %>% 
  mutate(cota_parte = area_terreno / unidades) %>% 
  arrange(desc(cota_parte)) %>% 
  head(10)
```

```{r, echo = FALSE}
outliers %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)

```

Exemplo do lote de 400.000 metros quadrados e apenas uma unidade habitacional.

```{r plot_outlier, cache = TRUE}
outlier <- outliers %>% first() %>% st_set_geometry("geometry")

ggplot() +
  geom_sf(data = lotes %>% st_crop(outlier %>% st_buffer(500))) +
  geom_sf(data = outlier, aes(geometry = geometry), fill = "darkblue") +
  theme_void()

```

```{r, echo = FALSE}
remove(outliers, outlier, lotes)
```

# Erros no join

Há alguns casos em que o join não encontra match na base de dados dos lotes. Uma possível explicação para este descompasso pode ser a desatualização da base do IPTU, visto que no geosampa a base de lotes sempre é a mais atualizada, visto que toda vez em que um lote é modificado ou surgem novos lotes, esta base é atualizada. Possivelmente a base do IPTU perdeu essas eventuais atualizações.

Uma possibilidade para contornar isso seria cruzar o setor e quadra do SQL, sem juntar com o lote com a base de quadras. Essa abordagem perderia um pouco da exatidão geográfica. Outra possibilidade seria de utilizar dados do logradouro para georreferenciar estes SQLs perdidos. Entretanto, como são dados residuais, isso tem impacto negligenciável na análise.

```{r erro_join, cache = TRUE}
IPTU.lotes %>% 
  mutate(erro = geometry %>% st_is_empty(),
         residencial = ifelse(residencial == 1, "Residencial", "Nao residencial")) %>% 
  st_drop_geometry() %>% 
  group_by(erro, residencial) %>% 
  summarize(n = n(),
            unidades = sum(unidades),
            area_construida = sum(area_construida)) %>% 
  group_by(residencial) %>% 
  mutate(prop = n/sum(n),
         prop_unidades = unidades / sum(unidades),
         prop_area_construida = area_construida / sum(area_construida)) %>% 
  pivot_wider(id_cols = c(erro), names_from = c(residencial), 
              values_from = n:prop) %>% 
  gt() %>% 
  tab_spanner(label = "Residencial", columns = contains("_Residencial")) %>% 
  tab_spanner(label = "Nao Residencial", columns = contains("_Nao Residencial")) %>% 
  cols_label_with(fn = ~ str_remove(., pattern = "_Residencial|_Nao residencial"))
```


```{r erros_geografica, cache = TRUE}
setor <- read_sf("dados/setor/SIRGAS_SHP_setorfiscal.shp") %>% 
  st_set_crs("epsg:31983") %>% 
  select(st_codigo)

IPTU.lotes %>% 
  mutate(erro = geometry %>% st_is_empty()) %>% 
  filter(erro, residencial == 1) %>% 
  group_by(setor) %>% 
  summarize(erros = n())  %>%
  mutate(erros = cut(erros, breaks = c(0, 50, 100, 200, 500, 1000, Inf))) %>% 
  left_join(setor, join_by(setor == st_codigo)) %>% 
  ggplot() +
  geom_sf(data = setor, color = "white") +
  geom_sf(aes(geometry = geometry, fill = factor(erros)), color = "white") +
  scale_fill_viridis_d() +
  labs(fill = "Número de erros", title = "Distribuição geográfica dos erros de join") +
  theme_void()
  
```

```{r, echo = FALSE}
remove(setor, erro_join)
```

## Microdados do Censo de 2022

É importante destacar que os resultados disponíveis são parciais do censo, com dados atualizados até o momento da divulgação. No entanto, mesmo parciais, esses dados podem ser extremamente úteis para suas análises.

Um ponto crucial a considerar é que o nível mínimo de observação georreferenciada nos microdados do censo são os setores censitários. Os setores censitários são unidades geográficas definidas pelo Instituto Brasileiro de Geografia e Estatística (IBGE) para coleta e tabulação de dados censitários. Eles são delimitados de forma a garantir uma cobertura completa e homogênea de todo o território nacional, facilitando a análise comparativa entre diferentes áreas geográficas. A delimitação geográfica do setor também considera questões logísticas para o entrevistador conseguir entrevistar a todos.


```{r read_censo, cache = TRUE}
# Read dados do censo 2022
censo <- read_sf("dados/censo/SP_Malha_Preliminar_2022.shp") %>% 
  filter(CD_MUN == "3550308") %>% 
  st_transform("epsg:31983") %>% # Sistema de coordenadas do geosampa
  select(id_setor_censitario = CD_SETOR, v0001:v0007) %>% 
  mutate(area_setor = st_area(geometry))
```

```{r, echo = FALSE}
censo %>% 
  ungroup() %>% sample_n(10) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

```{r plot_censo, cache = TRUE}
gg <- ggplot() +
  geom_sf(data = censo %>%
            mutate(densidade = v0001/area_setor,
                   decil = ntile(densidade, 10)),
          aes(fill = factor(decil)), color = NA) +
  scale_fill_viridis_d() +
  labs(fill = "Decil de densidade") +
  theme_void()

ggsave("tex/imagens/mapa.png", gg, width = 20, height = 20, dpi = 400)
```

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/mapa.png")
```

```{r}
descritiva <- censo %>% 
  st_drop_geometry() %>% 
  summarize("Total de pessoas" = sum(v0001),
            "Total de Domicílios" = sum(v0002),
            "Total de Domicílios Particulares Ocupados" = sum(v0007)) %>% 
  pivot_longer(everything())
```

```{r, echo = FALSE}
descritiva %>% 
  kbl(format.args = list(big.mark = ".")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
remove(descritiva)
```

```{r plot_distcentro, cache = TRUE}
censo %>% 
  mutate(distancia_centro = st_distance(geometry, 
                                        read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") %>% 
                                          st_set_crs("epsg:31983") %>% 
                                          filter(ds_nome == "SE")) %>% 
           as.numeric() %>% 
           cut(breaks = 10^3*(0:40), labels = FALSE)) %>% 
  st_drop_geometry() %>%
  group_by(distancia_centro) %>% 
  summarize(densidade = sum(v0001) / sum(as.numeric(area_setor) / 10^6)) %>% 
  ggplot(aes(x = distancia_centro, y = densidade)) +
  geom_col() +
  scale_y_continuous(labels = scales::comma_format(big.mark = ".")) +
  scale_x_continuous(labels = scales::comma_format(big.mark = ".")) +
  labs(x = "Distância ao centro em quilômetros", 
       y = "Densidade populacional por quilômetro quadrado") +
  theme_classic()
```

```{r}
censo %>% 
  mutate(distancia_centro = st_distance(geometry, 
                                        read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") %>% 
                                          st_set_crs("epsg:31983") %>% 
                                          filter(ds_nome == "SE")) %>% 
           as.numeric() / 1000,
         densidade = v0001 / as.numeric(area_setor)) %>% 
  filter(distancia_centro != 0) %>% 
  lm(densidade ~ exp(-distancia_centro), data = .) %>% 
  summary()
```


# Cruzamento entre a Base do Censo e a Base do IPTU

O processo de cruzamento foi realizado com base na intersecção das geometrias dos setores censitários e dos lotes do IPTU. Cada setor censitário e cada lote do IPTU possui uma geometria associada, representando sua área geográfica no mapa. Ao cruzar essas geometrias, é possível identificar quais lotes estão contidos em cada setor censitário e vice-versa.

É importante destacar que, em casos onde um lote foi dividido entre dois ou mais setores censitários, ocorrerá uma intersecção em ambas as áreas. Para lidar com essa situação, foi calculado o percentual da área do lote que está contida em cada setor censitário.


```{r join_IPTU-censo, cache = TRUE}
# Join dados do IPTU com do Censo através da intersecção das geometrias
IPTU.censo <- censo %>% 
  st_intersection(IPTU.lotes %>% st_as_sf()) %>% 
  as_tibble() %>% 
  rename(geometria_intersec = geometry) %>% 
  
  # Retomada das geometrias do setor e lotes
  left_join(censo %>% 
              as_tibble() %>% 
              select(id_setor_censitario, 
                     geometria_setor_censitario = geometry),
            by = join_by(id_setor_censitario)) %>% 
  left_join(IPTU.lotes %>% 
              as_tibble() %>% 
              select(setor, quadra, lote, 
                     geometria_lote = geometry),
            by = join_by(setor, quadra, lote)) %>% 
  
  # Cálculo de quanto % do lote está dentro do setor
  mutate(percent_intersec = as.numeric(st_area(geometria_intersec) / st_area(geometria_lote)))
```

```{r, echo = FALSE}
IPTU.censo %>% 
  ungroup() %>% sample_n(10) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)
```

## Erros no join

Alguns setores censitários não encontram pares na base de lotes. Isso acontece principalmente por conta de loteamentos irregulares e favelas, que não são contribuintes do IPTU, e, portanto, não constam na base. Isso não prejudica a análise, pois estes loteamentos não dependem da regulamentação urbana, então mudanças nos instrumentos e indicadores não impactariam essas regiões.

Outras falhas decorrem do erro do join da base do IPTU com lotes, como apontado anteriormente, mas estes casos são negligenciáveis.

```{r plot_erros_join_favelas, cache = TRUE}
distrito <- read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") %>% st_set_crs("epsg:31983")
lotes_irregulares <- read_sf("dados/lotes_irregulares/SIRGAS_SHP_loteamento.shp") %>%
  st_set_crs("epsg:31983")
favela <- read_sf("dados/favela/SIRGAS_SHP_favela.shp") %>% 
  st_set_crs("epsg:31983")

censo.pontos <- censo %>%
  select(id_setor_censitario, geometry, n = v0001) %>%
  mutate(pontos = round(n / 100)) %>% 
  as_tibble() %>% 
  left_join(censo %>% 
              anti_join(IPTU.censo %>% select(id_setor_censitario))) %>% 
  mutate(erro = is.na(v0001)) %>% 
  mutate(samples = map2(geometry, pontos, ~st_sample(.x, size = .y))) %>%
  unnest(cols = samples) %>%
  as_tibble()

gg <- censo.pontos %>% 
  ggplot() +
  geom_sf(data = distrito, color = NA) +
  geom_sf(data = st_union(favela %>% st_union() %>% st_buffer(10),
                          lotes_irregulares %>% st_union() %>% st_buffer(10)),
          aes(fill = "Favelas e lotes irregulares"), 
        color = "black", size = .1, alpha = .7) +
  geom_sf(aes(geometry = samples, color = erro), alpha = .25, size = .2) +
  scale_color_manual(values = c("TRUE" = NA,#248232
                               "FALSE" = "#006DAA"),
                     labels = NULL) +
  scale_fill_manual("", values = c("Favelas e lotes irregulares" = "#E0CBA8")) +
  labs(title = "População em <span style = 'color:#006DAA;'>áreas sem registro de IPTU</span> geralmente estão em <span style = 'color:#E0CBA8;'>favelas ou lotes irregulares</span>, cada ponto representa 100 pessoas") + 
  theme_void() +
  theme(plot.title = element_markdown(), legend.position = "none")

ggsave("tex/imagens/mapa_pontos.png", gg, width = 20, height = 20, dpi = 300)
```

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/mapa_pontos.png")
remove(favela, gg, lotes_irregulares, IPTU.lotes, censo.pontos)
```
## Função para plotar um setor censitário ou SQL específico

```{r}
view_geomtria <- function(geometria, zoom_out, colorir = TRUE){
  
  bbox <- geometria %>% 
    st_transform("epsg:31983") %>% 
    st_bbox()
  
  x_min <- (bbox$xmin - zoom_out) %>% as.numeric()
  y_min <- (bbox$ymin - zoom_out) %>% as.numeric()
  x_max <- (bbox$xmax + zoom_out) %>% as.numeric()
  y_max <- (bbox$ymax + zoom_out) %>% as.numeric()
  
  corte <- list(xmin = x_min - zoom_out, ymin = y_min - zoom_out, 
                xmax = x_max + zoom_out, ymax = y_max + zoom_out)
  
  df <- IPTU.censo %>%
    st_as_sf() %>%
    st_transform("epsg:31983") %>% 
    st_crop(corte %>% unlist()) %>% 
    mutate(densidade = v0001/area_setor,
           decil = ntile(densidade, 10),
           percent_intersec = round(percent_intersec * 100))
  
  if (colorir){gg <- df %>% 
      ggplot() +
      geom_sf(aes(geometry = geometria_setor_censitario, fill = factor(decil)), color = "white", lwd = 1.5)}
  else{gg <- df %>% 
      ggplot() +
      geom_sf(aes(geometry = geometria_setor_censitario), color = "white", lwd = 1.5)}
  
  gg +
    geom_sf(aes(geometry = geometria_intersec), fill = "red", color = "red", alpha = .25) +
    geom_sf_label(aes(geometry = geometria_intersec, label = percent_intersec), label.size = .01) +
    scale_fill_viridis_d() +
    labs(fill = "Decil de densidade") +
    theme(legend.position = "none") +
    coord_sf(xlim = c(x_min, x_max), ylim = c(y_min, y_max)) +
    theme_void()
}
```

## Exemplo de lote que é cortado por setor censitário

Demonstrativo do que acontece quando um lote está dividido em mais de um setor censitário. No fundo, há os setores censitários, coloridos de acordo com a densidade. Em vermelho, estão as geometrias dos lotes. Quando o lote não é cortado, sua área fica integralmente em um setor censitário. Quando um setor corta um lote, sua área é distribuída e o número representa o percentual da área que fica em cada setor censitário.


```{r mapa_lote_cortado, cache=TRUE}
gg <- view_geomtria(IPTU.censo %>% 
                filter(id_setor_censitario == "355030810000143P") %>% 
                select(geometria_setor_censitario) %>% 
                st_as_sf(),
              zoom_out = 50)

ggsave("tex/imagens/mapa_lote_corte.png", gg, width = 10, height = 10, dpi = 300)
```


```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/mapa_lote_corte.png")
```

## Casos de erro do procedimento

```{r erro_tabela, cache = TRUE}
caso.erro <- IPTU.censo %>%
  group_by(setor, quadra, lote) %>% 
  mutate(soma_percent_intersec = sum(percent_intersec) %>% round(2)) %>% 
  filter(soma_percent_intersec < 1)
```

```{r, echo = FALSE}
caso.erro %>% 
  ungroup() %>% sample_n(5) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                font_size = 10)

remove(caso.erro)
```

É possível observar que nestes casos, a soma do percentual não é 1 porque estão na borda da cidade, então o resto do lote se encontra em outros municípios. Estes erros não vão causar problemas.

```{r mapa_erro, cache = TRUE}
gg <- view_geomtria(IPTU.censo %>% 
                filter(setor == "160", quadra == "128", lote == "0008") %>% 
                select(geometria_lote) %>% 
                st_as_sf(),
              zoom_out = 100,
              colorir = FALSE)

ggsave("tex/imagens/mapa_erro.png", gg, width = 10, height = 8, dpi = 300)
```


```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("tex/imagens/mapa_erro.png")
```

# Regressão


```{r}
df <- IPTU.censo %>% 
  filter(residencial == 1, v0001 > 0) %>% 

  group_by(id_setor_censitario) %>% 
  summarize(
            
            # Setor censitário
            populacao = median(v0001),
            area_setor = median(area_setor) %>% as.numeric(),
            domicilios = median(v0002),
            domicilios_ocupados = median(v0007),
            geometry = first(geometria_setor_censitario),
            
            # Lote
            unidades = sum(unidades * percent_intersec),
            area_terreno = sum(area_terreno * percent_intersec),
            area_construida = sum(area_construida * percent_intersec),
            area_ocupada = sum(area_ocupada * percent_intersec),
            verticalizacao = weighted.mean(pavimentos, area_terreno * percent_intersec)) %>% 
  
  mutate(densidade = populacao / area_setor,
         cota_parte = area_terreno / unidades,
         cota_parte_censo = area_terreno / domicilios,
         CA = area_construida / area_terreno) %>% 
  
  mutate(distancia_centro = st_distance(geometry %>% st_centroid(), 
                                      read_sf("dados/distrito/SIRGAS_SHP_distrito.shp") %>% 
                                        st_set_crs("epsg:31983") %>% 
                                        filter(ds_nome == "SE")) %>% 
         as.numeric() / 1000)
  
```

# Dados finais

```{r}
ggplot() +
  geom_sf(data = censo, color = NA) +
  geom_sf(data = df %>%
            mutate(decil = ntile(densidade_setor, 10)),
          aes(fill = factor(decil), geometry = geometry), color = NA) +
  scale_fill_viridis_d() +
  labs(fill = "Decil de densidade") +
  theme_void()
```

```{r}

lm(densidade ~ CA + cota_parte + verticalizacao, data = df) %>% summary()
lm(log(densidade) ~ CA + log(cota_parte) + verticalizacao, data = df) %>% summary()

```

```{r}
split <- rsample::initial_split(df %>% select(-geometry), prop = 0.7)
train <- rsample::training(split)
test <- rsample::testing(split)
```

```{r}
lm_model <- lm(densidade ~ CA + cota_parte + verticalizacao, data = train) 
lm_preds <- predict(lm_model, newdata = test)
```

```{r}
rtree <- rpart::rpart(densidade ~ CA + cota_parte + verticalizacao, data = train)
visNetwork::visTree(rtree, direction = "LR", collapse = TRUE, legend = FALSE)
```

```{r}
rf_model <- ranger::ranger(densidade ~ CA + cota_parte + verticalizacao, 
                     data = train, num.trees = 1000, importance = "impurity")
rf_preds <- predict(rf_model, data = test)$predictions

rf_model_all <- ranger::ranger(densidade ~ ., 
                     data = train, num.trees = 1000, importance = "impurity")
rf_preds_all <- predict(rf_model_all, data = test)$predictions

ggplot(NULL, aes(x = rf_model_all$variable.importance,
                 y = fct_reorder(names(rf_model_all$variable.importance),
                                 rf_model_all$variable.importance))) +
    geom_col(fill = "darkblue", alpha = 0.75) +
    labs(x = "Predictor", y = "Importance", title = "Random Forest") +
    theme_bw()
```


```{r}
sqrt(mean((rf_preds - test$densidade)^2))
sqrt(mean((rf_preds_all - test$densidade)^2))
sqrt(mean((lm_preds - test$densidade)^2))
```

```{r}
ggplot(data = tibble(x = rf_preds, y = test$densidade)) +
  geom_point(aes(x = x, y = y)) +
  theme(aspect.ratio = 1) +
  coord_cartesian(xlim = c(0, .1), ylim = c(0, .1)) +
  geom_abline(slope = 1)
```


